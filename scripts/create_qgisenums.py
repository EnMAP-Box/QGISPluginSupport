# this script generates the qps/qgisenums.py which provided unified access to enumerations accross different QGIS API versions
import pathlib
import re
from typing import Dict, List

import qgis.core
import qgis.gui
QGIS_CORE_CLASSES = vars(qgis.core)
QGIS_GUI_CLASSES = vars(qgis.gui)

from qgis.core import Qgis

import urllib.request
url = r'https://raw.githubusercontent.com/qgis/QGIS/master/src/core/qgis.h'

path_qgisenums = pathlib.Path(__file__).parents[1] / 'qps' / 'qgisenums.py'

try:

    with urllib.request.urlopen(url) as response:
        code = response.read().decode('utf-8')

except urllib.error.URLError as e:
    print(f"Failed to download qgis.h: {e}")


code = re.sub('\n', ' ', code)
pattern = '/[*][^/]*Prior to.[^/]*/[ ]+enum[^:]*:'

rxSince = re.compile(r'\\since QGIS 3\.(\d+)')
rxPrior = re.compile(r'Prior to.*3\.(\d+) this was available as (Qgs[^ ]+)')
rxClass = re.compile(r'enum class ([^ ]+)')

class API_BREAK(object):

    def __init__(self, version_int: int, oldname:str, newname:str):
        self.version_int = version_int
        self.varname = f'QGIS_{newname.upper()}'
        self.oldname = oldname
        self.newname = newname



API_BREAKS: List[API_BREAK] = list()

for m in re.findall(pattern, code):

    matchSince = rxSince.search(m)
    matchPrior = rxPrior.search(m)
    matchClass = rxClass.search(m)

    nameNew = matchClass.group(1)
    nameOld = matchPrior.group(2)
    version_int = 30000
    version_int += int(100 * float(matchPrior.group(1)))

    if nameOld.endswith('.'):
        nameOld = nameOld[0:-1]
    nameOld = nameOld.replace('::', '.')
    API_BREAKS.append(API_BREAK(version_int=version_int,
                       oldname=nameOld,
                       newname=nameNew,
                       ))

lines = [f'# autogenerated file. do not modify',
         'from qgis.core import Qgis',
         ' ']

# init all

API_BREAKS = sorted(API_BREAKS, key=lambda b:b.newname)

switchlines = []
required_imports = set()

for b in API_BREAKS:

    if '.' in b.oldname:
        p = ''
        required_import = b.oldname.split(".")[0]
        required_imports.add(required_import)
    else:
        p = 'Qgis.'

    switchline = f'{b.varname} = Qgis.{b.newname} if Qgis.versionInt() >= {b.version_int} else {p}{b.oldname}'
    switchlines.append(switchline)


required_imports = sorted(required_imports)

core_classes = []
gui_classes = []
for i in required_imports:
    if i in QGIS_CORE_CLASSES:
        core_classes.append(i)
    elif i in QGIS_GUI_CLASSES:
        gui_classes.append(i)
    else:
        raise NotImplementedError()
lines.append('\n#  Import old locations')
if len(core_classes) > 0:
    lines.append('from qgis.core import (' + ', '.join(core_classes) + ')')
if len(gui_classes) > 0:
    lines.append('from qgis.gui import (' + ', '.join(gui_classes) + ')')
lines.append('\n#  API Switches')
lines.extend(switchlines)


with open(path_qgisenums, 'w', encoding='utf8') as f:
    f.write('\n'.join(lines))